# Template-of-Templates Architecture

## Overview

The `agentsmgr populate` command uses a template-of-templates approach to generate tool-specific configurations directly in downstream projects from structured data sources. This architecture separates source data from format-specific templates, enabling clean generation of configurations for multiple AI coding tools without committing generated artifacts to version control.

## Architecture

### Directory Structure

```
data/
├── configurations/                    # Tool-agnostic configuration metadata
│   ├── commands/
│   │   ├── cs-release-final.toml      # Command configuration
│   │   ├── cs-conform-python.toml
│   │   └── ...
│   └── agents/
│       ├── python-conformer.toml      # Agent configuration
│       └── ...
├── contents/                          # Coder-specific content bodies
│   ├── commands/
│   │   ├── claude/
│   │   │   ├── cs-release-final.md    # Content without frontmatter
│   │   │   └── cs-conform-python.md
│   │   ├── opencode/                  # Falls back to claude/ if missing
│   │   └── gemini/                    # No fallback - different syntax
│   └── agents/
│       ├── claude/
│       │   └── python-conformer.md
│       ├── opencode/                  # Falls back to claude/ if missing  
│       └── gemini/                    # No fallback - different syntax
└── templates/                         # Generic, reusable templates
    ├── command.md.jinja               # For Claude/Opencode commands
    ├── command.toml.jinja             # For Gemini commands
    ├── agent.md.jinja                 # For Claude/Opencode agents
    └── agent.toml.jinja               # For Gemini agents

Note: Settings templates and hook scripts will be distributed via Copier template 
under `template/.auxiliary/configuration/<coder>/` rather than generated by agentsmgr, 
as they require coordination with the base project structure and hook mechanisms 
that differ across coders.
```

### Source Data Format

Source data will be structured in TOML files following project standards (hyphenated key names, table arrays rather than hardcoded table names). The source format must cover all fields present in the various destination formats (Claude Code, Opencode, Gemini, etc.), either directly or via derivation.

Command and agent data structures will be designed by the implementation team to accommodate the diverse frontmatter and configuration requirements across different AI coding tools.

### Tool Templates Handle Format Differences

Tool-specific Jinja2 templates will handle the different frontmatter and format requirements for each AI coding tool. The specific template formats will be designed after the source data structure is finalized.

## Command Implementation

The `agentsmgr populate` command performs the following operations:

### Core Process
• **Configuration Detection**: Load project configuration from Copier answers file or use defaults
• **Data Source Fetching**: Clone/fetch specific version of agents-common repository to local cache  
• **Content Generation**: Generate commands and agents for each selected coder using tool-specific templates

### Key Steps
1. Parse source specification (e.g., `agents-common@agents-3`) to identify repository and version
2. Maintain local git cache of data source repository with tag-based updates
3. Load TOML data files (commands, agents) from source repository
4. Load tool-specific Jinja2 templates for each selected coder
5. Generate content files in target project's `.auxiliary/configuration/<coder>/` directories
6. Ensure proper file permissions and directory structure

### Configuration Sources
• **Primary**: Copier answers file at `.auxiliary/configuration/copier-answers--agents.yaml`
• **Fallback**: Default configuration (languages=["python"], coders=["claude"])

### Configuration Normalization

The `agentsmgr populate` command will normalize configuration data before passing to templates:

**Key Transformation:**
- Hyphenated keys → underscore keys for template access
- `argument-hint` becomes `argument_hint`  
- `allowed-tools` becomes `allowed_tools`

**Dot-Notation Access:**
- Configuration tables become namespace objects
- `coder.name`, `coder.model`, `coder.mode` accessible via dot notation
- Enables clean template conditionals: `{% if coder.name == 'claude' %}`

**Template Variables:**
- `content`: Raw content from `data/contents/{type}/{coder}/{name}.md`
- `coder`: Matching entry from `coders` table array for target coder
- All configuration fields: `name`, `description`, `argument_hint`, `color`, etc.
- `allowed_tools`: Processed and mapped tool specifications

**Content Fallback Strategy:**
- Claude ↔ Opencode: Bidirectional fallback (compatible markdown format and syntax)
- Gemini: No fallback (incompatible syntax: `{{args}}` vs `$ARGUMENTS`, `!{cmd}` vs `!`cmd``)
- If `data/contents/commands/opencode/cs-release-final.md` missing → use `claude/` version
- If `data/contents/commands/claude/cs-release-final.md` missing → use `opencode/` version
- If `data/contents/commands/gemini/cs-release-final.md` missing → error (no fallback)

### Allowed Tools Specification

Commands and agents specify required capabilities using semantic tool specifications that `agentsmgr` maps to coder-specific syntax during generation.

**Source Format (in TOML configuration):**
```toml
allowed-tools = [ 
  'write',                                    # File modification capabilities
  'web-search',                              # Web search functionality  
  'web-fetch',                               # Web content retrieval
  { tool = 'shell', matches = [              # Shell command execution
    'git add *', 
    'git commit *',
    'hatch --env develop run *'
  ] },
  { mcp-server = 'librovore', tools = [      # MCP server tools
    'query-inventory', 
    'query-content' 
  ] }
]
```

**Mapping to Coder-Specific Syntax:**

The `agentsmgr populate` command maps semantic tool specifications to coder-specific allowed-tools entries:

- **Claude Code**: `'write'` → `'Edit, MultiEdit, Write'`; `'git add *'` → `'Bash(git add:*)'`; `'librovore.query-inventory'` → `'mcp__librovore__query_inventory'`
- **Opencode**: Similar markdown-based syntax (implementation-specific)
- **Gemini**: Implementation-dependent tool specification format

**Shell Pattern Syntax:**
- Wildcard `*` means "accept anything past this point" (inspired by `sudoers` rather than globs)
- Each command with shell operators treated as separate permission (e.g., `git log | head` requires permissions for both `git log *` and pipeline operators)

**Implementation Notes:**
- Mapping logic initially implemented in `agentsmgr` code (deferring configuration-based DSL until post-MVP)
- Domain restrictions and broader permissions handled via general permissions model, not command/agent level
- MCP server versioning handled via downstream repository temporary overrides until upstream updates
- File system read tools (`Read`, `Glob`, `Grep`, `LS`) enabled universally without granular restrictions

Implementation details including specific interfaces, error handling, and coding standards will be determined by the development team according to project conventions.

## Benefits

### Clean Separation
- **Source data** contains semantic information in tool-agnostic format
- **Templates** handle tool-specific format requirements  
- **Generated output** optimized for each tool's expectations

### Format Evolution Support
- Claude and Opencode frontmatter can diverge over time
- Gemini's TOML agent specifications vs Claude's Markdown
- New tools can be added with new template sets

### Language-Aware Generation
- Commands show appropriate examples for selected languages
- Scripts are filtered based on language selection
- Settings templates reference correct language-specific tools

### Tool-Specific Customization
- Each tool gets format-appropriate configuration
- Tool-specific metadata sections in source data
- Templates can implement tool-unique features

### Future Extensibility
- New AI tools: add template directory and extend copier choices
- New languages: extend data examples
- New configuration types: add new template files

## Integration Workflows

### New Project Creation
```bash
# 1. Create base project
copier copy python-project-common.git my-project

# 2. Add agents configuration  
cd my-project
copier copy agents-common.git@agents-3 .

# 3. agentsmgr populate runs automatically via Copier hooks
```

### Agent Configuration Updates  
```bash
# Update to latest agent configurations
copier update --answers-file .auxiliary/configuration/copier-answers--agents.yaml --skip-answered

# Or update to specific version
agentsmgr populate --source=agents-common@agents-4
```

### Manual Population (Copier-agnostic)
```bash
# Works in any project structure
agentsmgr populate --source=agents-common@agents-3
# Uses default languages=["python"], coders=["claude"]
```

This architecture enables downstream projects to receive dynamic agent content generation without committing generated artifacts, while maintaining single-source-of-truth for configuration data and fast iteration cycles for command/agent development.